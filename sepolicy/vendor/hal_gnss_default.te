# Most HALs are not allowed to use network sockets. Qcom library
# libqdi is used across multiple processes which are clients of
# netmgrd including the GNSS HAL. libqdi first attempts to get the network
# interface using an IOCTL on a UDP INET socket, which isn't allowed here.
# If that fails, it falls back to using libc's if_nameindex() which requires
# a netlink route socket, which HALs may use. Due to the initial
# attempt to use a UDP socket, we still see a selinux denial,
# but it is safe to ignore.

dontaudit hal_gnss_default self:udp_socket create;
allow hal_gnss_default location_data_file:dir create;
allow hal_gnss_default location_data_file:fifo_file create_file_perms;

allow hal_gnss location_data_file:dir { rw_dir_perms };
allow hal_gnss location_data_file:file create_file_perms;
allow hal_gnss location_data_file:sock_file { create unlink };
allow hal_gnss location:unix_dgram_socket sendto;
allow hal_gnss location_socket:sock_file create_file_perms;
allow hal_gnss location_socket:dir rw_dir_perms;

unix_socket_connect(hal_gnss, location, location)

allow hal_gnss self:{
    socket
    netlink_socket
    netlink_generic_socket
} create_socket_perms_no_ioctl;
allow hal_gnss self:netlink_route_socket { create_socket_perms_no_ioctl nlmsg_read nlmsg_write };

allow hal_gnss self:socket rw_socket_perms;
allow hal_gnss sysfs:file r_file_perms;
allow hal_gnss sysfs_data:file r_file_perms;
allow hal_gnss sysfs:dir r_dir_perms;
allow hal_gnss ssr_device:chr_file r_file_perms;

allow hal_gnss self:socket { create ioctl };
allowxperm hal_gnss self:socket ioctl msm_sock_ipc_ioctls;
qmux_socket(hal_gnss)
vndbinder_use(hal_gnss_default)

allow hal_gnss_default diag_device:chr_file rw_file_perms;
